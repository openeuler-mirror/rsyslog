From 54cbda6cde9bf667d699f7b0093d48a3983edb42 Mon Sep 17 00:00:00 2001
From: Rainer Gerhards <rgerhards@adiscon.com>
Date: Fri, 4 Mar 2022 11:39:11 +0100
Subject: [PATCH] imptcp bugfix: worker thread starvation on extreme traffic

When connectes were totally busy, without any pause, the assigened worker
did never terminate its reading loop. As such, it could not service any
other conenctions. If this happened multiple time and to all configured
workers, all other connections could not be processed at all. This extreme
scenario is very unlikely, as the whole issue is relatively unlikely.

In practice, the issue could lead to somewhat degraded performance and
resolved itself after some time (in practice no connection is 100% busy
for an extended period of time).

Note that this patch sets a fixed limit of 16 iterations for very busy
connections. This sounds like a good compromise between non-starvation
and performance. The exact number may be made configurable if there
is really need to.

Conflict:NA
Reference:https://github.com/rsyslog/rsyslog/commit/34e72ced504458d804f8d1049be67ea8cc00a4b4
---
 plugins/imptcp/imptcp.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/plugins/imptcp/imptcp.c b/plugins/imptcp/imptcp.c
index e47a7c9..72e32dd 100644
--- a/plugins/imptcp/imptcp.c
+++ b/plugins/imptcp/imptcp.c
@@ -10,7 +10,7 @@
  *
  * File begun on 2010-08-10 by RGerhards
  *
- * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.
+ * Copyright 2007-2022 Rainer Gerhards and Adiscon GmbH.
  *
  * This file is part of rsyslog.
  *
@@ -1391,7 +1391,7 @@ addEPollSock(epolld_type_t typ, void *ptr, int sock, epolld_t **pEpd)
 	epd->ptr = ptr;
 	epd->sock = sock;
 	*pEpd = epd;
-	epd->ev.events = EPOLLIN|EPOLLET|EPOLLONESHOT;
+	epd->ev.events = EPOLLIN|EPOLLONESHOT;
 	epd->ev.data.ptr = (void*) epd;
 
 	if(epoll_ctl(epollfd, EPOLL_CTL_ADD, sock, &(epd->ev)) != 0) {
@@ -1938,11 +1938,12 @@ sessActivity(ptcpsess_t *const pSess, int *const continue_polling)
 	int remsock = 0; /* init just to keep compiler happy... :-( */
 	sbool bEmitOnClose = 0;
 	char rcvBuf[128*1024];
+	int runs = 0;
 	DEFiRet;
 
 	DBGPRINTF("imptcp: new activity on session socket %d\n", pSess->sock);
 
-	while(1) {
+	while(runs++ < 16) {
 		lenBuf = sizeof(rcvBuf);
 		lenRcv = recv(pSess->sock, rcvBuf, lenBuf, 0);
 
-- 
2.33.0

