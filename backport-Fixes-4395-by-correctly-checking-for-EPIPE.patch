From 640af90afaf13bef5a99a458ed8e862359588d8f Mon Sep 17 00:00:00 2001
From: Kailash Sethuraman <hsaliak@gmail.com>
Date: Thu, 13 Jan 2022 13:52:46 -0500
Subject: [PATCH] Fixes #4395 by correctly checking for EPIPE.

kmsg is a unique device, which can recover from EPIPE errors.
The original code checked for this, but checked the return value for the libc
read call, which always returns -1 and sets the appropriate errno.

This meant that when an EPIPE error actually happened, the fd was infinitely retried. The 'for loop' was broken out of, but the readikmsg() function is repeatedly called.

Note: there is an additional bug here. The readikmsg function needs better error checking on the fd. I suspect that this was rarely an issue because /dev/kmsg goes truly invalid when the system is actually shutting down.

The fix here is to check the return value as well as the errno.

Conflict:NA
Reference:https://github.com/rsyslog/rsyslog/commit/feb6420148c351072a190990622b58124fd44506
---
 contrib/imkmsg/kmsg.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/contrib/imkmsg/kmsg.c b/contrib/imkmsg/kmsg.c
index beb4076..5a3f45e 100644
--- a/contrib/imkmsg/kmsg.c
+++ b/contrib/imkmsg/kmsg.c
@@ -214,7 +214,7 @@ readkmsg(void)
 		if (i > 0) {
 			/* successful read of message of nonzero length */
 			pRcv[i] = '\0';
-		} else if (i == -EPIPE) {
+		} else if (i < 0 && errno == EPIPE) {
 			imkmsgLogIntMsg(LOG_WARNING,
 					"imkmsg: some messages in circular buffer got overwritten");
 			continue;
-- 
2.33.0

